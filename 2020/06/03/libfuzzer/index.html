<!DOCTYPE html><html class="appearance-dark" lang="zh-CN"><head><meta charset="UTF-8"><title>libFuzzer使用总结教程</title><meta name="description" content="Winter is coming"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/source/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Fstark's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">libFuzzer使用总结教程</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about/">关于</a></h3><h3 class="is-inline-block"><a href="/archives/">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about/">关于</a></h3><h3 class="is-inline-block"><a href="/archives/">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E7%AF%87"><span class="toc-text">理论篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libFuzzer%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">libFuzzer是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libFuzzer%E4%B8%8E%E4%BC%A0%E7%BB%9FFuzz%E7%9B%B8%E6%AF%94%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">libFuzzer与传统Fuzz相比的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Ffuzz%E9%9D%A2%E4%B8%B4%E9%97%AE%E9%A2%98"><span class="toc-text">传统fuzz面临问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libFuzzer%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">libFuzzer的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libFuzzer%E7%9A%84%E7%90%86%E8%AE%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">libFuzzer的理论过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%AF%87"><span class="toc-text">实践篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99Fussing-Target%EF%BC%88hardness%EF%BC%89"><span class="toc-text">编写Fussing Target（hardness）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5"><span class="toc-text">编译连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%B5%8B%E8%AF%95"><span class="toc-text">开始测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Seed-corpus-%E7%A7%8D%E5%AD%90%E8%AF%AD%E6%96%99%E5%BA%93"><span class="toc-text">Seed corpus 种子语料库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%96%99%E5%BA%93%E6%A0%B7%E6%9C%AC%E9%9B%86"><span class="toc-text">精简语料库样本集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C"><span class="toc-text">并行运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dictionaries-%E5%AD%97%E5%85%B8"><span class="toc-text">Dictionaries 字典</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E7%AF%87"><span class="toc-text">实例篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5Freeimage%E4%B8%BA%E4%BE%8B%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">以Freeimage为例进行测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E4%BB%B6%E4%B8%80"><span class="toc-text">附件一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/fuzz"><i class="tag post-item-tag">fuzz</i></a><a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98"><i class="tag post-item-tag">漏洞挖掘</i></a><a href="/tags/libFuzzer"><i class="tag post-item-tag">libFuzzer</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">libFuzzer使用总结教程</h1><time class="has-text-grey" datetime="2020-06-03T03:24:38.000Z">2020-06-03</time><article class="mt-2 post-content"><p>本篇文章简述libFuzzer原理，配合各个实例介绍参数功能意义，为最终进一步的完全利用奠定基础</p>
<a id="more"></a>

<h2 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h2><h3 id="libFuzzer是什么？"><a href="#libFuzzer是什么？" class="headerlink" title="libFuzzer是什么？"></a>libFuzzer是什么？</h3><p>LibFuzzer在概念上与American Fuzzy Lop（<a target="_blank" rel="noopener" href="http://lcamtuf.coredump.cx/afl/">AFL</a>）类似，但它是在单个进程中执行了所有模糊测试。进程内的模糊测试可能更具针对性，由于没有进程反复启动的开销，因此与AFL相比可能更快。</p>
<p>按照官方定义，<strong>libFuzzer</strong> 是一个<code>in-process（进程内的）</code>，<code>coverage-guided（以覆盖率为引导的）</code>，<code>evolutionary（进化的）</code> 的 <code>fuzz</code> 引擎，是 <code>LLVM</code> 项目的一部分。据<a target="_blank" rel="noopener" href="https://security.googleblog.com/2016/08/guided-in-process-fuzzing-of-chrome.html">Google官方技术博客</a>的表述，这三个特性可分别解释为如下意义：</p>
<ul>
<li><p><code>in-process（进程内的）</code>：<em>we mean that we don’t launch a new process for every test case, and that we mutate inputs directly in memory.</em>  我们并没有为每一个测试用例都开启一个新进程，而是在一个进程内直接将数据投放在内存中。</p>
</li>
<li><p><code>coverage-guided（以覆盖率为引导的）</code>：<em>we mean that we measure code coverage for every input, and accumulate test cases that increase overall coverage.</em> 我们对每一个输入都进行代码覆盖率的计算，并且不断积累这些测试用例以使代码覆盖率最大化。</p>
</li>
<li><p><code>evolutionary（进化的）</code>：fuzz按照类型分为3类，这是最后一种。</p>
<blockquote>
<p>第一类是基于生成的<code>Generation Based</code>通过对目标协议或文件格式建模的方法，从零开始产生测试用例，没有先前的状态；</p>
<p>第二类为基于突变的<code>Evolutionary</code>基于一些规则，从已有的数据样本或存在的状态变异而来；</p>
<p>最后一种就是基于进化的<code>Evolutionary</code>包含了上述两种，同时会根据代码覆盖率的回馈进行变异。</p>
</blockquote>
</li>
</ul>
<p>LibFuzzer和要被测试的库链接在一起，通过一个特殊的模糊测试进入点（目标函数），用测试用例feed（喂）要被测试的库。fuzzer会跟踪哪些代码区域已经测试过，然后在输入数据的语料库上产生变异，来最大化代码覆盖。其中代码覆盖的信息由LLVM的SanitizerCoverage插桩提供。</p>
<h3 id="libFuzzer与传统Fuzz相比的特点"><a href="#libFuzzer与传统Fuzz相比的特点" class="headerlink" title="libFuzzer与传统Fuzz相比的特点"></a>libFuzzer与传统Fuzz相比的特点</h3><h4 id="传统fuzz面临问题"><a href="#传统fuzz面临问题" class="headerlink" title="传统fuzz面临问题"></a>传统fuzz面临问题</h4><ul>
<li>搜索空间过于广泛</li>
<li>无法fuzz特定的函数</li>
<li>难以fuzz网络协议</li>
<li>常规fuzz速度太慢</li>
</ul>
<p>传统的 <code>fuzz</code> 大多通过对已有的样本 <strong>按照预先设置好的规则</strong> 进行变异产生测试用例，然后喂给 目标程序同时监控目标程序的运行状态，这类 <code>fuzz</code> 有很多，比如: <code>peach</code> , <code>FileFuzz</code> 等。找寻漏洞的过程形如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhps16nolj30fs0aganf.jpg" alt="image-20200605210407383"></p>
<h4 id="libFuzzer的优势"><a href="#libFuzzer的优势" class="headerlink" title="libFuzzer的优势"></a>libFuzzer的优势</h4><ul>
<li>In-process, in-memory</li>
<li>会主动引导fuzz过程</li>
<li>针对函数/协议级别的fuzz非常有效率</li>
<li>1000x的快</li>
<li>编写基于libfuzzer的fuzzer很容易</li>
<li>可以单独跟随一个单元进行检测</li>
</ul>
<p>libFuzzer所有的程序的主要功能都是对一些 <strong>字节序列</strong> 进行操作，基于这一个事实（<code>libfuzzer</code> 生成 随机的 字节序列 ，扔给 待<code>fuzz</code> 的程序，然后检测是否有异常出现） 所以在 <code>libfuzzer</code> 看来，<code>fuzz</code> 的目标 其实就是一个 以 <strong>字节序列</strong> 为输入的 <strong>函数</strong>。其过程形如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhpsxzyddj30g10ay49d.jpg" alt="image-20200605210458829"></p>
<h3 id="libFuzzer的理论过程"><a href="#libFuzzer的理论过程" class="headerlink" title="libFuzzer的理论过程"></a>libFuzzer的理论过程</h3><p>简单理解 <code>libfuzzer</code> 就是，如果我们要 <code>fuzz</code> 一个程序，找到一个入口函数，然后利用</p>
<pre><code>extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;
    .......
    .......
&#125;</code></pre>
<p>接口（hardness），我们可以拿到 <code>libfuzzer</code> 生成的 <strong>测试数据以及测试数据的长度</strong>，我们的任务就是<strong>把这些生成的测试数据 传入到目标程序中 让程序来处理 测试数据， 同时要尽可能的触发更多的代码逻辑</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhqqg37osj30ig0a4aar.jpg" alt="image-20200605213711784"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhqr5qln1j30ig09kaar.jpg" alt="image-20200605213753311"></p>
<p><code>libfuzzer</code> 已经把 一个 <code>fuzzer</code> 的核心（样本生成引擎和异常检测系统） 给做好了， 我们需要做的是根据目标程序的逻辑，把 <code>libfuzzer</code> 生成的数据，交给目标程序处理，然后在编译时采取合适的 <code>Sanitizer</code> 用于检测运行时出现的内存错误。</p>
<h2 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h2><p>实践部分建议学习查阅Google的**<a target="_blank" rel="noopener" href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">libFuzzerTutorial</a>**，内容比较完善跟随不同的案例逐个验证libFuzzer的具体功能，但是因为介绍每个功能采用的案例不同，可能对于新手来说割裂感比较严重，我把共用的部分摘取总结出来把这部分变成一个工具书，理想的是在一个具体案例中能够运用一遍所有的常用功能，这样更加连贯，具体实践放在最后的案例篇。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方推荐使用Ubuntu16.04 x64安装，其本身是<code>llvm</code>项目的一部分，和<code>clang</code>是亲兄弟，二者项目源码分别可见于<a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/fuzzer%E5%92%8Chttps://github.com/llvm/llvm-project/tree/master/clang%EF%BC%8C%E5%B0%B1%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E9%87%8C%E9%9D%A2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%A8%8D%E5%BE%AE%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E7%9A%84clang%E9%83%BD%E5%B7%B2%E7%BB%8F%E5%86%85%E7%BD%AElibFuzzer%E4%BA%86%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8llvm%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/fuzzer和https://github.com/llvm/llvm-project/tree/master/clang，就在同一个仓库里面，现在稍微新的版本的clang都已经内置libFuzzer了，也可以使用llvm官方提供的脚本进行安装。</a></p>
<pre><code class="bash">#!/bin/bash -eux
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
################################################################################

sudo apt-get update
sudo apt-get upgrade -y
sudo apt-get autoremove -y

sudo apt-get install -y libc6-dev binutils libgcc-5-dev

LLVM_DEP_PACKAGES=&quot;build-essential make cmake ninja-build git python2.7&quot;
sudo apt-get install -y $LLVM_DEP_PACKAGES

WORK_DIR=$PWD
mkdir -p $WORK_DIR/src

# Checkout
cd $WORK_DIR/src &amp;&amp; git clone --depth 1 http://llvm.org/git/llvm.git
cd $WORK_DIR/src/llvm/tools &amp;&amp; git clone --depth 1 http://llvm.org/git/clang.git
cd $WORK_DIR/src/llvm/projects &amp;&amp; git clone --depth 1 http://llvm.org/git/compiler-rt.git
cd $WORK_DIR/src/llvm/projects &amp;&amp; git clone --depth 1 http://llvm.org/git/libcxx.git
cd $WORK_DIR/src/llvm/projects &amp;&amp; git clone --depth 1 http://llvm.org/git/libcxxabi.git

# Uncomment if you want *fresh* libFuzzer from checkouted repository.
#rm -r $WORK_DIR/libFuzzer/Fuzzer
#cp -r $WORK_DIR/src/llvm/projects/compiler-rt/lib/fuzzer/ $WORK_DIR/libFuzzer/Fuzzer

# Build &amp; Install
mkdir -p $WORK_DIR/work/llvm
cd $WORK_DIR/work/llvm

# Consider adding of -DCMAKE_INSTALL_PREFIX=%PATH% flag, if you do not want to
# install fresh llvm binaries into standard system paths.
cmake -G &quot;Ninja&quot; \
      -DLIBCXX_ENABLE_SHARED=OFF -DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON \
      -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \
      $WORK_DIR/src/llvm
ninja -j$(nproc)
sudo ninja install
rm -rf $WORK_DIR/work/llvm</code></pre>
<h3 id="编写Fussing-Target（hardness）"><a href="#编写Fussing-Target（hardness）" class="headerlink" title="编写Fussing Target（hardness）"></a>编写Fussing Target（hardness）</h3><p>libFuzzer要求实现一个<code>fuzz target</code>作为被测对象的接口，这个入口点用来接收 libFuzzer 生成的 测试用例（比特序列）</p>
<p>官方文档中的代码示例如下：</p>
<pre><code class="c++">// fuzz_target.cc
extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123;
  DoSomethingInterestingWithMyAPI(Data, Size);
  return 0;  // Non-zero return values are reserved for future use.
&#125;</code></pre>
<p>名称参数返回值类型都不能动，并且注意参数中传来的字节数组<code>Data</code>是通过底层const修饰了的，也就是不允许修改其中数据。</p>
<ul>
<li><p><code>data</code> 是 <code>libFuzzer</code> 生成的 测试数据， <code>size</code> 是数据的长度</p>
</li>
<li><p><code>fuzz</code> 引擎会在一个进程中进行多次 <code>fuzz</code>， 所以其效率非常高</p>
</li>
<li><p>要能处理各种各样的输入 （空数据， 大量的 或者 畸形的数据…)</p>
</li>
<li><p>内部不会调用 <code>exit()</code></p>
</li>
<li><p>如果使用多线程的话，在函数末尾要把 线程 <code>join</code></p>
</li>
</ul>
<p>fuzzer target（即<code>LLVMFuzzerTestOneInput</code>函数）目的是作为被测对象与libFuzzer库之间的一个中转接口，其作用在于接受libFuzzer提供的输入数据<code>Data</code>字节串，（可能还需要进行数据格式转换，）然后传递给实际的被测函数（如上述示例中的<code>DoSomethingInterestingWithMyAPI</code>）。</p>
<p>官方文档中对其有如下要求：</p>
<ul>
<li><p>The fuzzing engine will execute the fuzz target many times with different inputs in the same process.</p>
<p>函数会在同一进程中多次执行，即被循环调用。</p>
</li>
<li><p>It must tolerate any kind of input (empty, huge, malformed, etc).</p>
<p>必须接受所有格式的输入。</p>
</li>
<li><p>It must not exit() on any input.</p>
<p>不允许主动退出，前面说了是循环调用，退出了就没法循环了。</p>
</li>
<li><p>It may use threads but ideally all threads should be joined at the end of the function.</p>
<p>可以开线程，但返回之前必须结束它，原因还是那个——循环调用，自己的线程自己关。</p>
</li>
<li><p>It must be as deterministic as possible. Non-determinism (e.g. random decisions not based on the input bytes) will make fuzzing inefficient.</p>
<p>其执行必须结果必须是具有确定性的，两次的Data如果一致，则两次执行的结果也必须一致。</p>
</li>
<li><p>It must be fast. Try avoiding cubic or greater complexity, logging, or excessive memory consumption.</p>
<p>速度，速度！毕竟模糊测试需要进行大量数据的测试。</p>
</li>
<li><p>Ideally, it should not modify any global state (although that’s not strict).</p>
<p>不允许修改全局变量，因为在同一个进程里，修改全局变量会导致下一次运行时读取的是修改后的结果，可能会违反前面说的确定性原则。</p>
</li>
<li><p>Usually, the narrower the target the better. E.g. if your target can parse several data formats, split it into several targets, one per format.</p>
<p>尽量窄范围测试，如果测试处理多种数据格式的目标，还是分割成多个子目标为好。这既是处于速度考量，也是出于模糊测试数据变异的效果考量。</p>
</li>
</ul>
<h3 id="编译连接"><a href="#编译连接" class="headerlink" title="编译连接"></a>编译连接</h3><p>文档中给出的编译链接命令大致可归纳为：</p>
<pre><code class="bash">clang++ -g -O1 -fsanitize=fuzzer,address -fsanitize-coverage=trace-pc-guard \
fuzz_target.cc ../../libFuzzer/Fuzzer/libFuzzer.a \
-o mytarget_fuzzer</code></pre>
<ul>
<li><p><code>-g</code>和<code>-O1</code>是gcc/clang的通用选项，前者保留调试信息，使错误消息更易于阅读；后者指定优化等级为1（保守地少量优化），但这两个选项不是必须的。</p>
</li>
<li><p><code>-fsanitize=fuzzer</code>才是关键，通过这个选项启用libFuzzer，向libFuzzer提供进程中的覆盖率信息，并与libFuzzer运行时链接。</p>
</li>
<li><p>除了<code>fuzzer</code>外，还可以附加其他sanitize（漂白剂）选项也可以加进来，如<code>-fsanitize=fuzzer,address</code>同时启用了地址检查。关于地址漂白剂详细作用可以查看llvm的官方文档<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a></p>
<blockquote>
<p>常用内存错误检测工具</p>
<p><code>AddressSanitizer</code>: 检测 <code>uaf</code>, 缓冲区溢出，<code>stack-use-after-return</code>, <code>container-overflow</code>等内存访问错误，使用-fsanitize = address</p>
<p><code>MemorySanitizer（MSAN）</code>： 检测未初始化内存的访问，使用-fsanitize = memory。MSAN不能与其他消毒剂结合使用，应单独使用。</p>
<p><code>UndefinedBehaviorSanitizer（UBSAN）</code>： 检测一些其他的漏洞，整数溢出，类型混淆等，检测到C / C ++的各种功能的使用，这些功能已明确列出来导致未定义的行为。使用-fsanitize = undefined，也可以将ASAN和UBSAN合并到一个版本中。</p>
</blockquote>
</li>
<li><p><code>-fsanitize-coverage=trace-pc-guard</code>: 为 <code>libfuzzer</code> 提供代码覆盖率信息</p>
</li>
<li><p><code>libFuzzer.a</code>: 为libfuzzer项目中执行<code>build.sh</code> 编译好生成的 <code>libFuzzer.a</code></p>
</li>
<li><p><code>-o fuzzer</code>:一个 <strong>生成 测试用例， 交给目标程序测试，然后检测程序是否出现异常</strong> 的程序</p>
</li>
</ul>
<p>这一步骤整体过程就是通过clang的<code>-fsanitize=fuzzer</code>选项可以启用libFuzzer，这个选项在编译和链接过程中生效，实现了条件判断语句和分支执行的记录，并且辅以libFuzzer中的库函数，通过生成不同的测试样例然后能够获得代码的覆盖率情况，最终实现所谓的fuzz testing。</p>
<p>对这一过程感兴趣的可以阅读<a target="_blank" rel="noopener" href="https://i-m.dev/posts/20190831-143715.html">libFuzzer编译链接</a>，博主对比了正常clang编译和使用libFuzzer编译从准备—预处理—编译—汇编—链接全过程的对比，展示了libFuzzer在具体编译过程中的作用。</p>
<p>这一步最终生成的就是这个fuzzer。</p>
<h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p>被测程序在启用<code>libFuzzer</code>并编译链接后，即成为了一个可接受用户参数的命令行程序，直接执行程序便是启动测试。</p>
<p>一般格式：</p>
<pre><code class="bash">./your-fuzzer -flag1=val1 -flag2=val2 ... dir1 dir2 ...</code></pre>
<p>flags代表各个控制测试过程的选项参数，可以提供零到任意个，但必须是严格的<code>-flag=value</code>形式</p>
<ul>
<li>选项前导用单横线，即使选项是一个词而非单个字符</li>
<li>选项必须要提供对应的值，即使只是一个开关选项如<code>-help</code>，必须要写作<code>-help=1</code>，且选项与值中间只能用等号，不能用空格。</li>
</ul>
<p>dirs表示语料库目录，它们的内容都会被读取作为初始语料库，但测试过程中生成的新输入只会被保存到第一个目录下。</p>
<p>常用有以下部分参数，全文我将附在博客的最后附件1中.</p>
<p><em>对于开关选项（如<code>help</code>），效用一列表示当参数启用时（<code>-help=1</code>）的效果</em></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认</th>
<th>效用</th>
</tr>
</thead>
<tbody><tr>
<td>verbosity</td>
<td>1</td>
<td>运行时输出详细日志</td>
</tr>
<tr>
<td>seed</td>
<td>0</td>
<td>随机种子。如果为0，则自动生成</td>
</tr>
<tr>
<td>runs</td>
<td>-1</td>
<td>单个测试运行的次数（-1表示无限）</td>
</tr>
<tr>
<td>max_len</td>
<td>0</td>
<td>测试输入的最大长度。若为0，libFuzzer会自行猜测</td>
</tr>
<tr>
<td>minimize_crash</td>
<td>0</td>
<td>如果为1，则最小化提供的崩溃输入。与-runs = N或-max_total_time = N一起使用以限制尝试次数。</td>
</tr>
<tr>
<td>reduce_inputs</td>
<td>1</td>
<td>尝试减小输入的大小，同时保留其全部功能集</td>
</tr>
<tr>
<td>fork</td>
<td>0</td>
<td>在子过程中发生fuzzing的实验模式</td>
</tr>
<tr>
<td>ignore_timeouts</td>
<td>1</td>
<td>在fork模式下忽略超时</td>
</tr>
<tr>
<td>ignore_crashes</td>
<td>0</td>
<td>在fork模式下忽略崩溃</td>
</tr>
<tr>
<td>ignore_ooms</td>
<td>1</td>
<td>在fork模式下忽略OOM</td>
</tr>
<tr>
<td>cross_over</td>
<td>1</td>
<td>交叉输入</td>
</tr>
<tr>
<td>rss_limit_mb</td>
<td>2048</td>
<td>内存使用限制，以Mb为单位。使用0则禁用限制。</td>
</tr>
<tr>
<td>mutate_depth</td>
<td>5</td>
<td>每个输入连续突变的数量</td>
</tr>
<tr>
<td>shuffle</td>
<td>1</td>
<td>启动时打乱初始语料库</td>
</tr>
<tr>
<td>prefer_small</td>
<td>1</td>
<td>打乱语料库时将小输入置于优先位置</td>
</tr>
<tr>
<td>timeout</td>
<td>1200</td>
<td>若为正，表示单元运行最大秒数。超时会被提前中止</td>
</tr>
<tr>
<td>error_exitcode</td>
<td>77</td>
<td>libFuzzer本身出错时的退出码</td>
</tr>
<tr>
<td>timeout_exitcode</td>
<td>77</td>
<td>libFuzzer超时退出码</td>
</tr>
<tr>
<td>max_total_time</td>
<td>0</td>
<td>若为正，表示整个模糊测试运行最大秒数</td>
</tr>
<tr>
<td>dict</td>
<td>0</td>
<td>提供输入关键字的字典</td>
</tr>
<tr>
<td>use_counters</td>
<td>1</td>
<td>使用<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/SanitizerCoverage.html#coverage-counters">覆盖率计数器</a>生成命中代码块的频率的近似计数；默认为1。</td>
</tr>
<tr>
<td>help</td>
<td>0</td>
<td>打印帮助并退出</td>
</tr>
<tr>
<td>merge</td>
<td>0</td>
<td>不损失覆盖率前提下，将第2/3/4/…个语料库合并到第一个中去</td>
</tr>
<tr>
<td>merge_control_file</td>
<td>0</td>
<td>指定合并进程的控制文件，用于恢复合并状态</td>
</tr>
<tr>
<td>jobs</td>
<td>0</td>
<td>运行的作业数量。所有作业的输出会被重定向到fuzz-JOB.log。</td>
</tr>
<tr>
<td>workers</td>
<td>0</td>
<td>运行作业的并发进程数。若为0，实验CPU核心数一半</td>
</tr>
<tr>
<td>reload</td>
<td>1</td>
<td>每N秒载主语料库，以知悉其他进程发现的单元</td>
</tr>
<tr>
<td>only_ascii</td>
<td>0</td>
<td>仅生成ASCII（isprint + isspace）输入</td>
</tr>
<tr>
<td>artifact_prefix</td>
<td>0</td>
<td>提供将模糊处理工件（崩溃，超时或缓慢的输入）另存为<code>$（artifact_prefix）file</code>时要使用的前缀。默认为空。</td>
</tr>
<tr>
<td>exact_artifact_path</td>
<td>0</td>
<td>如果为空则忽略（默认）。如果为非空，则将失败（崩溃，超时）时的单个工件写为<code>$（exact_artifact_path）</code>。这将覆盖 <code>-artifact_prefix，</code>并且不会在文件名中使用校验和。请勿将相同的路径用于多个并行进程。</td>
</tr>
<tr>
<td>detect_leaks</td>
<td>1</td>
<td>如果为1（默认值）并且启用了LeakSanitizer，则尝试在模糊测试期间检测内存泄漏（即，不仅在关闭时）。</td>
</tr>
<tr>
<td>print_final_stats</td>
<td>0</td>
<td>退出时打印统计信息</td>
</tr>
<tr>
<td>print_corpus_stats</td>
<td>0</td>
<td>退出时打印语料库元素统计信息</td>
</tr>
<tr>
<td>print_coverage</td>
<td>0</td>
<td>退出时打印覆盖率信息</td>
</tr>
<tr>
<td>close_fd_mask</td>
<td>0</td>
<td>为1则在关闭stdout，为2则关闭stderr，为3则关闭二者</td>
</tr>
</tbody></table>
<p>重运行模式：</p>
<pre><code class="bash">./your-fuzzer -flag1=val1 -flag2=val2 ... file1 file2 ...</code></pre>
<p>与上面一样，但是选项后面接的是文件列表而非文件夹列表，这些输入样例将会重新读取并输入运行，不会产生新样例，在回归测试时十分有用。</p>
<p>这里有几个选项功能是值得单独说一下的</p>
<h4 id="Seed-corpus-种子语料库"><a href="#Seed-corpus-种子语料库" class="headerlink" title="Seed corpus 种子语料库"></a>Seed corpus 种子语料库</h4><p>corpus语料库就是给目标程序的各种各样的输入</p>
<pre><code class="bash">mkdir MY_CORPUS
./your-fuzzer MY_CORPUS/ seeds/</code></pre>
<p>当基于libFuzzer的模糊器以另一个目录作为参数执行时，它将首先递归地从每个目录中读取文件（在本例中MY_CORPUS/和seeds/都读），并对所有目录执行目标函数。然后，任何触发感兴趣的代码路径的输入将被写回到第一个语料库目录（在本例中为<code>MY_CORPUS</code>）。一般情况下我们将相关文件放在seeds的位置下，MY_CORPUS/目录为空，这样运行后生成的样本就存在MY_CORPUS/中了。</p>
<h4 id="精简语料库样本集"><a href="#精简语料库样本集" class="headerlink" title="精简语料库样本集"></a>精简语料库样本集</h4><p>在模糊测试期间，测试语料库可能会增长到很大容量。如果希望最小化语料库，即创建具有相同覆盖率的语料库子集但容量却小很多，这就是一件性价比十分高的事情了。</p>
<pre><code class="bash">mkdir corpus1_min
./your-fuzzer -merge=1 corpus1_min corpus1</code></pre>
<ul>
<li><code>corpus1_min</code>: 精简后的样本集存放的位置</li>
<li><code>corpus1</code>: 原始样本集存放的位置</li>
</ul>
<h4 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h4><p>提高模糊测试效率的另一种方法是使用更多的CPU。如果您使用<code>-jobs=N</code>它运行模糊器，它将产生N个独立的作业，但最多不超过拥有的内核数的一半。用于<code>-workers=M</code>设置允许的并行作业数。</p>
<p>当指定了多个任务时，程序启动时会先产生一个<code>master</code>进程，同时并发启动相应数量个<code>worker</code>进程，master会把jobs分配到workers上去执行，当某个任务结束后，相应进程终止，同时master会启动一个新的任务进程分配到对应的worker上，平均每个worker上会分配<em>jobs/workers</em>个任务。</p>
<pre><code class="bash">./your-fuzzer MY_CORPUS/ seeds/ -jobs=8</code></pre>
<p>在8核计算机上，这将产生4个并行工作器。如果其中一个被退出，将自动创建另一个，最多8个。</p>
<pre><code class="bash">fuzzer -jobs=8
  ├─sh -c ./fuzzer &gt;fuzz-0.log 2&gt;&amp;1
  │   └─fuzzer
  │       └─&#123;fuzzer&#125;
  ├─sh -c ./fuzzer &gt;fuzz-1.log 2&gt;&amp;1
  │   └─fuzzer
  │       └─&#123;fuzzer&#125;
  ├─sh -c ./fuzzer &gt;fuzz-2.log 2&gt;&amp;1
  │   └─fuzzer
  │       └─&#123;fuzzer&#125;
  ├─sh -c ./fuzzer &gt;fuzz-3.log 2&gt;&amp;1
  │   └─fuzzer
  │       └─&#123;fuzzer&#125;</code></pre>
<h4 id="Dictionaries-字典"><a href="#Dictionaries-字典" class="headerlink" title="Dictionaries 字典"></a>Dictionaries 字典</h4><p>字典最早是afl在2015年一篇博客上提出的<a target="_blank" rel="noopener" href="https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html">afl-fuzz: making up grammar with a dictionary in hand</a>，</p>
<p>基本思路就是应用程序都是都是<strong>处理具有一定格式的数据</strong>，比如 <code>xml</code> 文档， <code>png</code>图片等等。 这些数据中会有一些<strong>特殊字符序列 （或者说关键字）</strong>， 比如 在 <code>xml</code> 文档中 就有 <code>CDATA</code>,  等，<strong>png图片</strong> 就有 <strong>png 图片头</strong>。</p>
<p>如果我们事先就把这些 <strong>字符序列</strong> 列举出来， <code>fuzz</code> 直接使用这些关键字去 组合，就会就可以减少很多没有意义的 尝试，同时还有可能会走到更深的程序分支中去。</p>
<p><code>Dictionary</code> 就是实现了这种思路。 <code>libfuzzer</code> 和 <code>afl</code> 使用的 <code>dictionary</code> 文件的语法是一样的， 所以可以直接拿 afl 里面的 <code>dictionary</code> 文件来给 <code>libfuzzer</code> 使用。</p>
<p>如下是libFuzzer官方文档中的字典示例</p>
<pre><code class="bash"># Lines starting with &#39;#&#39; and empty lines are ignored.

# Adds &quot;blah&quot; (w/o quotes) to the dictionary.
kw1=&quot;blah&quot;
# Use \\ for backslash and \&quot; for quotes.
kw2=&quot;\&quot;ac\\dc\&quot;&quot;
# Use \xAB for hex values
kw3=&quot;\xF7\xF8&quot;
# the name of the keyword followed by &#39;=&#39; may be omitted:
&quot;foo\x0Abar&quot;</code></pre>
<ul>
<li><code>#</code> 开头的行 和 空行会被忽略</li>
<li><code>kw1=</code> 这些就类似于注释， 没有意义</li>
<li>真正有用的是由 <code>&quot;</code> 包裹的<strong>字串</strong>，这些 <strong>字串</strong> 就会作为一个个的关键字， <code>libfuzzer</code> 会用它们进行组合来生成样本。</li>
</ul>
<p><code>libfuzzer</code> 使用 <code>-dict</code> 指定 <code>dict</code> 文件，下面使用 <code>xml.dict</code> 为 <code>dictionary</code> 文件，进行 <code>fuzz</code>。</p>
<pre><code class="bash">./your-fuzzer -dict=DICTIONARY_FILE</code></pre>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>当fuzzer成功运行之后，信息会输出在屏幕上。输出行具有事件代码和统计信息的形式。常见的事件代码是：</p>
<ul>
<li><code>READ</code> fuzzer已从语料库目录中读取了所有提供的输入样本。</li>
<li><code>INITED</code> fuzzer已完成初始化，其中包括通过被测代码运行每个初始输入样本。</li>
<li><code>NEW</code> fuzzer创建了一个测试输入，该输入涵盖了被测代码的新区域。此输入将保存到主要语料库目录。</li>
<li><code>pulse</code> fuzzer已生成 2的n次方个输入（定期生成以使用户确信fuzzer仍在工作）。</li>
<li><code>DONE</code> fuzzer已完成操作，因为它已达到指定的迭代限制（<code>-runs</code>）或时间限制（<code>-max_total_time</code>）。</li>
<li><code>RELOAD</code> fuzzer在定期从语料库目录中重新加载输入；这使它能够发现其他fuzzer进程发现的任何输入（请参阅<a target="_blank" rel="noopener" href="https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#parallel-fuzzing">并行模糊化</a>）。</li>
</ul>
<p>每条输出行还报告以下统计信息（非零时）：</p>
<ul>
<li><code>cov：</code> 执行当前语料库所覆盖的代码块或边的总数。</li>
<li><code>ft：</code> libFuzzer使用不同的信号来评估代码覆盖率：边缘覆盖率，边缘计数器，值配置文件，间接调用方/被调用方对等。这些组合的信号称为<em>功能</em>（ft：）。</li>
<li><code>corp：</code> 当前内存中测试语料库中的条目数及其大小（以字节为单位）。</li>
<li><code>exec/s：</code> 每秒模糊器迭代的次数。</li>
<li><code>rss：</code> 当前的内存消耗。</li>
</ul>
<p>对于<code>NEW</code>事件，输出行还包含有关产生新输入的变异操作的信息：</p>
<ul>
<li><code>L：</code> 新输入的大小（以字节为单位）。</li>
<li><code>MS: &lt;n&gt; &lt;operations&gt;</code> 用于生成输入的变异操作的计数和列表。</li>
</ul>
<p>我们以如下样例作解释：</p>
<pre><code class="bash">INFO: Seed: 1608565063
INFO: Loaded 1 modules (37 guards): [0x788ec0, 0x788f54), 
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0  READ units: 1
#1  INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 11Mb
#3  NEW    cov: 4 ft: 4 corp: 2/4b exec/s: 0 rss: 12Mb L: 3 MS: 2 InsertByte-InsertByte-
#3348   NEW    cov: 5 ft: 5 corp: 3/65b exec/s: 0 rss: 12Mb L: 61 MS: 2 ChangeByte-InsertRepeatedBytes-
#468765 NEW    cov: 6 ft: 6 corp: 4/78b exec/s: 0 rss: 49Mb L: 13 MS: 4 CrossOver-ChangeBit-EraseBytes-ChangeByte-
#564131 NEW    cov: 7 ft: 7 corp: 5/97b exec/s: 0 rss: 56Mb L: 19 MS: 5 InsertRepeatedBytes-InsertByte-ChangeByte-InsertByte-InsertByte-
=================================================================
==32049==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200072bb93 at pc 0x000000528540 bp 0x7ffdb3439100 sp 0x7ffdb34390f8
READ of size 1 at 0x60200072bb93 thread T0
    ......................................................
    ......................................................
    ......................................................

0x60200072bb93 is located 0 bytes to the right of 3-byte region [0x60200072bb90,0x60200072bb93)
allocated by thread T0 here:
   ......................................................
   ......................................................
   ......................................................

SUMMARY: AddressSanitizer: heap-buffer-overflow /home/haclh/vmdk_kernel/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)
Shadow bytes around the buggy address:
  0x0c04800dd720: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c04800dd730: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd
  0x0c04800dd740: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c04800dd750: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c04800dd760: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd
=&gt;0x0c04800dd770: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800dd780: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800dd790: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800dd7a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800dd7b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800dd7c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
......................................................
......................................................
==32049==ABORTING
MS: 1 CrossOver-; base unit: 38a223b0988bd9576fb17f5947af80b80203f0ef
0x46,0x55,0x5a,
FUZ
artifact_prefix=&#39;./&#39;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60
Base64: RlVa</code></pre>
<p>首先我们可以看出来<code>Seed: 1608565063</code> 说明这次的种子数据，如果我们想重现重新运行<code>-seed=1608565063</code>以得到相同的结果。其次<code>-max_len is not provided, using 64</code> ， <code>-max_len</code> 用于设置最大的数据长度，因为没有设置fuzzer会自己猜测，这里设置的数据不大于64KB。</p>
<p>接下来 <code>#</code> 开头的行是 <code>fuzz</code> 过程中找到的路径信息</p>
<pre><code class="bash"># 564131 NEW    cov: 7 ft: 7 corp: 5/97b exec/s: 0 rss: 56Mb L: 19 MS: 5 InsertRepeatedBytes-InsertByte-ChangeByte-InsertByte-InsertByte-</code></pre>
<p>我们可以看出来libFuzzer尝试了至少564131个输入（<code>#564131</code>），发现了5个输入，总共97个字节（<code>corp: 5/97b</code>），它们总共覆盖了7个<em>覆盖点</em>（<code>cov: 7</code>）。我们可以将覆盖点视为代码中的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Basic_block">基本块</a>。</p>
<pre><code class="bash">==32049==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200072bb93 at pc 0x000000528540 bp 0x7ffdb3439100 sp 0x7ffdb34390f8
READ of size 1 at 0x60200072bb93 thread T0</code></pre>
<p>这个信息说明在其中一个输入上，AddressSanitizer已检测到<code>heap-buffer-overflow</code>错误并中止了执行。</p>
<pre><code class="bash">artifact_prefix=&#39;./&#39;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</code></pre>
<p>倒数第二行是触发漏洞的测试用例，在退出进程之前，libFuzzer已创建了一个文件，其中包含触发崩溃的字节和所有信息，要重现崩溃而无模糊运行可以使用</p>
<pre><code class="bash">ASAN_OPTIONS=symbolize=1 ./first_fuzzer ./crash-0eb8e4ed029b774d80f2b66408203801
# ASAN_OPTIONS=symbolize=1 用于显示栈的符号信息</code></pre>
<p>来重现crash</p>
<p>如果我们在fuzzer运行的选项里有使用字典 <code>-dictionary</code>和<code>-print_final_stats</code>执行完打印统计信息，最后的输出可能还会多出两块，形如下面</p>
<pre><code class="bash">###### Recommended dictionary. ######
&quot;X\x00\x00\x00\x00\x00\x00\x00&quot; # Uses: 1228
&quot;prin&quot; # Uses: 1353
...........................
...........................
...........................
&quot;U&lt;/UTrri\x09&lt;/UTD&quot; # Uses: 61
###### End of recommended dictionary. ######
Done 1464491 runs in 301 second(s)
stat::number_of_executed_units: 1464491
stat::average_exec_per_sec:     4865
stat::new_units_added:          1407
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              407</code></pre>
<p>开始由 <code>####</code> 夹着的是 <code>libfuzzer</code> 在 <code>fuzz</code> 过程中挑选出来的 <code>dictionary</code>， 同时还给出了使用的次数，这些 <code>dictionary</code> 可以在以后 <code>fuzz</code> 同类型程序时 节省 <code>fuzz</code> 的时间。</p>
<p>然后以 <code>stat:</code> 开头的是一些 fuzz 的统计信息， 主要看 <code>stat::new_units_added</code> 表示整个 <code>fuzz</code> 过程中触发了多少个代码单元。</p>
<p>可以看到直接 <code>fuzz</code> , <code>5</code>分钟 触发了 <code>1407</code> 个代码单元</p>
<h2 id="实例篇"><a href="#实例篇" class="headerlink" title="实例篇"></a>实例篇</h2><h3 id="以Freeimage为例进行测试"><a href="#以Freeimage为例进行测试" class="headerlink" title="以Freeimage为例进行测试"></a>以Freeimage为例进行测试</h3><p>我们首先把最新版本的Freeimage给拉到本地，然后解压</p>
<pre><code class="bash">wget https://downloads.sourceforge.net/freeimage/FreeImage3180.zip
unzip FreeImage3180.zip</code></pre>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsagnbtqj316n09bn5y.jpg" alt="截屏2020-06-07 下午3.30.33"></p>
<p>对这个源包先进行一下编译</p>
<pre><code class="bash">pushd FreeImage

# b44ExpLogTable.cpp only contains a definition of main().
sed -i &#39;s/Source\/OpenEXR\/IlmImf\/b44ExpLogTable.cpp//&#39; Makefile.srcs
make LIBRARIES=-lc++ -j$(nproc)

popd</code></pre>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsf6ax3uj30yh0eshbw.jpg" alt="截屏2020-06-07 下午4.06.37"></p>
<p>编译成功后在Freeimage/Dist里应该就生成了<code>libfreeimage.a</code> ,<code>.h</code>和 <code> .o</code>文件</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsk1djg6j30f406l0tf.jpg" alt="截屏2020-06-07 下午4.11.18"></p>
<p>随后根据Freeimage的功能特性写对应的hardness，也就是fuzzing target，这里直接使用OSS-fuzz的project中给出的Freeimage的hardness，在根目录保存为load_from_memory_fuzzer.cc文件</p>
<pre><code class="c++">#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;FreeImage.h&gt;

namespace &#123;

// Returns true if the format should be attempted to loaded from memory.
bool SafeToLoadFromMemory(FREE_IMAGE_FORMAT fif) &#123;
  // For now, just load if it is a BMP. Future heuristics may need to be based
  // on the expected size in different formats for memory regions to avoid OOMs.
  return fif == FIF_BMP;
&#125;

&#125;  // namespace

extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) &#123;
  static bool initialized = false;
  if (!initialized) &#123;
    FreeImage_Initialise();
  &#125;

  if (size &gt; 100 * 1000) &#123;
    return 0;
  &#125;

  std::vector&lt;uint8_t&gt; fuzzer_data_vector(data, data + size);
  FIMEMORY* fiMem = FreeImage_OpenMemory(
      reinterpret_cast&lt;unsigned char*&gt;(fuzzer_data_vector.data()),
      fuzzer_data_vector.size());

  FREE_IMAGE_FORMAT fif = FreeImage_GetFileTypeFromMemory(fiMem, 0);
  if (SafeToLoadFromMemory(fif)) &#123;
    FIBITMAP* fiBitmap = FreeImage_LoadFromMemory(fif, fiMem);
    FreeImage_Unload(fiBitmap);
  &#125;
  FreeImage_CloseMemory(fiMem);

  return 0;
&#125;</code></pre>
<p>接下来的步骤就是开始编译fuzzer，把对应参数输入在后面，使用clang++开始编译</p>
<pre><code class="bash">clang++ -g -fsanitize=fuzzer,address \
load_from_memory_fuzzer.cc ./FreeImage/Dist/libfreeimage.a \
-o load_from_memory_fuzzer</code></pre>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjstwsua4j30g402wdh5.jpg" alt="截屏2020-06-07 下午4.20.47"></p>
<p>出现了一点错误，看来是Freeimage.h文件没有找到，需要用-I 指定一下文件的路径让他可以找到</p>
<pre><code class="bash">clang++ -g -fsanitize=fuzzer,address -I&#39;/home/fstark/FreeImage/Dist&#39; \
load_from_memory_fuzzer.cc ./FreeImage/Dist/libfreeimage.a \
-o load_from_memory_fuzzer</code></pre>
<p>这次成功了，发现已经成功生成了load_from_memory_fuzzer</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjswpiuydj30hw05zgnu.jpg" alt="截屏2020-06-07 下午4.23.28"></p>
<p>不加任何附加命令直接运行一下试试，发现可以跑了，就是速度不怎么快</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjt13bmogj30hx0apdkv.jpg" alt="截屏2020-06-07 下午4.27.42"></p>
<p>当我做到这一步时，学长点拨前面的编译是有问题的，运行时结果仅覆盖57是肯定有问题的。通过在开会时看学长的讲解分析，确实在编译的时候直接拉freeimage的包，里面的makefile需要修改。这里把编译选项更改一下，其实我又回顾了一下之前clusterfuzz踩的坑，其中心脏滴血在编译的时候就要求加上<code>-fsanitize=address,fuzzer-no-link</code>，但之前没有细心注意。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl6s8fzqjj30ha08eq3y.jpg" alt="image-20200608210908837"></p>
<p>我们在makefile.gnu里把默认的03改成01，再加上这几条推荐的编译选项，不得不说自己对于常见的编译过程真是陌生，要不是靠学长又是进坑几个小时，真要抽个时间好好补补这部分的内容了，做个编译过程大梳理和常见编译器对比什么的</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl6u71z4kj30wu087jv6.jpg" alt="image-20200608211104945"></p>
<p>这样再编译一遍，不放样本，速度也好了很多</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl8e9ir1ej30pj0fctht.jpg" alt="image-20200608220457407"></p>
<p>简单准备个样本集，再精简一下</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gflvdgizo9j30ra0alahs.jpg" alt="截屏2020-06-09 上午11.08.57"></p>
<p>简单跑一下，这次就可以跑出crash了，但是很多是重复的在跑的时候附加的选项还是要多多限制，逐渐摸索，但整体流程就是这样了</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gflvetkoakj31020i6dur.jpg" alt="截屏2020-06-09 上午11.18.29"></p>
<h2 id="附件一"><a href="#附件一" class="headerlink" title="附件一"></a>附件一</h2><table>
<thead>
<tr>
<th>Flags:</th>
<th>value</th>
<th>strictly in form -flag=value</th>
</tr>
</thead>
<tbody><tr>
<td>verbosity</td>
<td>1</td>
<td>Verbosity level.</td>
</tr>
<tr>
<td>seed</td>
<td>0</td>
<td>Random seed. If 0, seed is generated.</td>
</tr>
<tr>
<td>runs</td>
<td>-1</td>
<td>Number of individual test runs (-1 for infinite runs).</td>
</tr>
<tr>
<td>max_len</td>
<td>0</td>
<td>Maximum length of the test input. If 0, libFuzzer tries to guess a good value based on the corpus and reports it.</td>
</tr>
<tr>
<td>lea_control</td>
<td>100</td>
<td>Try generating small inputs first, then try larger inputs over time. Specifies the rate at which the length limit is increased (smaller == faster). If 0, immediately try inputs with size up to max_len. Default value is 0, if LLVMFuzzerCustomMutator is used.</td>
</tr>
<tr>
<td>seed_inputs</td>
<td>0</td>
<td>A comma-separated list of input files to use as an additional seed corpus. Alternatively, an “@” followed by the name of a file containing the comma-seperated list.</td>
</tr>
<tr>
<td>cross_over</td>
<td>1</td>
<td>If 1, cross over inputs.</td>
</tr>
<tr>
<td>mutate_depth</td>
<td>5</td>
<td>Apply this number of consecutive mutations to each input.</td>
</tr>
<tr>
<td>reduce_depth</td>
<td>0</td>
<td>Experimental/internal. Reduce depth if mutations lose unique features</td>
</tr>
<tr>
<td>shuffle</td>
<td>1</td>
<td>Shuffle inputs at startup</td>
</tr>
<tr>
<td>prefer_small</td>
<td>1</td>
<td>If 1, always prefer smaller inputs during the corpus shuffle.</td>
</tr>
<tr>
<td>timeout</td>
<td>1200</td>
<td>Timeout in seconds (if positive). If one unit runs more than this number of seconds the process will abort.</td>
</tr>
<tr>
<td>error_exitcode</td>
<td>77</td>
<td>When libFuzzer itself reports a bug this exit code will be used.</td>
</tr>
<tr>
<td>timeout_exitcode</td>
<td>70</td>
<td>When libFuzzer reports a timeout this exit code will be used.</td>
</tr>
<tr>
<td>max_total_time</td>
<td>0</td>
<td>If positive, indicates the maximal total time in seconds to run the fuzzer.</td>
</tr>
<tr>
<td>help</td>
<td>0</td>
<td>Print help.</td>
</tr>
<tr>
<td>fork</td>
<td>0</td>
<td>Experimental mode where fuzzing happens in a subprocess</td>
</tr>
<tr>
<td>ignore_timeouts</td>
<td>1</td>
<td>Ignore timeouts in fork mode</td>
</tr>
<tr>
<td>ignore_ooms</td>
<td>1</td>
<td>Ignore OOMs in fork mode</td>
</tr>
<tr>
<td>ignore_crashes</td>
<td>0</td>
<td>Ignore crashes in fork mode</td>
</tr>
<tr>
<td>merge</td>
<td>0</td>
<td>If 1, the 2-nd, 3-rd, etc corpora will be merged into the 1-st corpus. Only interesting units will be taken. This flag can be used to minimize a corpus.</td>
</tr>
<tr>
<td>stop_file</td>
<td>0</td>
<td>Stop fuzzing ASAP if this file exists</td>
</tr>
<tr>
<td>merge_control_file</td>
<td>0</td>
<td>Specify a control file used for the merge process. If a merge process gets killed it tries to leave this file in a state suitable for resuming the merge. By default a temporary file will be used.</td>
</tr>
<tr>
<td>minimize_crash</td>
<td>0</td>
<td>If 1, minimizes the provided crash input. Use with -runs=N or -max_total_time=N to limit the number attempts. Use with -exact_artifact_path to specify the output. Combine with ASAN_OPTIONS=dedup_token_length=3 (or similar) to ensure that the minimized input triggers the same crash.</td>
</tr>
<tr>
<td>cleanse_crash</td>
<td>0</td>
<td>If 1, tries to cleanse the provided crash input to make it contain fewer original bytes. Use with -exact_artifact_path to specify the output.</td>
</tr>
<tr>
<td>use_counters</td>
<td>1</td>
<td>Use coverage counters</td>
</tr>
<tr>
<td>use_memmem</td>
<td>1</td>
<td>Use hints from intercepting memmem, strstr, etc</td>
</tr>
<tr>
<td>use_value_profile</td>
<td>0</td>
<td>Experimental. Use value profile to guide fuzzing.</td>
</tr>
<tr>
<td>use_cmp</td>
<td>1</td>
<td>Use CMP traces to guide mutations</td>
</tr>
<tr>
<td>shrink</td>
<td>0</td>
<td>Experimental. Try to shrink corpus inputs.</td>
</tr>
<tr>
<td>reduce_inputs</td>
<td>1</td>
<td>Try to reduce the size of inputs while preserving their full feature sets</td>
</tr>
<tr>
<td>jobs</td>
<td>0</td>
<td>Number of jobs to run. If jobs &gt;= 1 we spawn this number of jobs in separate worker processes with stdout/stderr redirected to fuzz-JOB.log.</td>
</tr>
<tr>
<td>workers</td>
<td>0</td>
<td>Number of simultaneous worker processes to run the jobs. If zero, “min(jobs,NumberOfCpuCores()/2)” is used.</td>
</tr>
<tr>
<td>reload</td>
<td>1</td>
<td>Reload the main corpus every <N> seconds to get new units discovered by other processes. If 0, disabled</td>
</tr>
<tr>
<td>report_slow_units</td>
<td>10</td>
<td>Report slowest units if they run for more than this number of seconds.</td>
</tr>
<tr>
<td>only_ascii</td>
<td>0</td>
<td>If 1, generate only ASCII (isprint+isspace) inputs.</td>
</tr>
<tr>
<td>dict</td>
<td>0</td>
<td>Experimental. Use the dictionary file.</td>
</tr>
<tr>
<td>artifact_prefix</td>
<td>0</td>
<td>Write fuzzing artifacts (crash, timeout, or slow inputs) as $(artifact_prefix)file</td>
</tr>
<tr>
<td>exact_artifact_path</td>
<td>0</td>
<td>Write the single artifact on failure (crash, timeout) as $(exact_artifact_path). This overrides -artifact_prefix and will not use checksum in the file name. Do not use the same path for several parallel processes.</td>
</tr>
<tr>
<td>print_pcs</td>
<td>0</td>
<td>If 1, print out newly covered PCs.</td>
</tr>
<tr>
<td>print_funcs</td>
<td>2</td>
<td>If &gt;=1, print out at most this number of newly covered functions.</td>
</tr>
<tr>
<td>print_final_stats</td>
<td>0</td>
<td>If 1, print statistics at exit.</td>
</tr>
<tr>
<td>print_corpus_stats</td>
<td>0</td>
<td>If 1, print statistics on corpus elements at exit.</td>
</tr>
<tr>
<td>print_coverage</td>
<td>0</td>
<td>If 1, print coverage information as text at exit.</td>
</tr>
<tr>
<td>dump_coverage</td>
<td>0</td>
<td>Deprecated.</td>
</tr>
<tr>
<td>handle_segv</td>
<td>1</td>
<td>If 1, try to intercept SIGSEGV.</td>
</tr>
<tr>
<td>handle_bus</td>
<td>1</td>
<td>If 1, try to intercept SIGBUS.</td>
</tr>
<tr>
<td>handle_abrt</td>
<td>1</td>
<td>If 1, try to intercept SIGABRT.</td>
</tr>
<tr>
<td>handle_ill</td>
<td>1</td>
<td>If 1, try to intercept SIGILL.</td>
</tr>
<tr>
<td>handle_fpe</td>
<td>1</td>
<td>If 1, try to intercept SIGFPE.</td>
</tr>
<tr>
<td>handle_int</td>
<td>1</td>
<td>If 1, try to intercept SIGINT.</td>
</tr>
<tr>
<td>handle_term</td>
<td>1</td>
<td>If 1, try to intercept SIGTERM.</td>
</tr>
<tr>
<td>handle_xfsz</td>
<td>1</td>
<td>If 1, try to intercept SIGXFSZ.</td>
</tr>
<tr>
<td>handle_usr1</td>
<td>1</td>
<td>If 1, try to intercept SIGUSR1.</td>
</tr>
<tr>
<td>handle_usr2</td>
<td>1</td>
<td>If 1, try to intercept SIGUSR2.</td>
</tr>
<tr>
<td>lazy_counters</td>
<td>0</td>
<td>If 1, a performance optimization isenabled for the 8bit inline counters. Requires that libFuzzer successfully installs its SEGV handler</td>
</tr>
<tr>
<td>close_fd_mask</td>
<td>0</td>
<td>If 1, close stdout at startup; if 2, close stderr; if 3, close both. Be careful, this will also close e.g. stderr of asan.</td>
</tr>
<tr>
<td>detect_leaks</td>
<td>1</td>
<td>If 1, and if LeakSanitizer is enabled try to detect memory leaks during fuzzing (i.e. not only at shut down).</td>
</tr>
<tr>
<td>purge_allocator_interval</td>
<td>1</td>
<td>Purge allocator caches and quarantines every <N> seconds. When rss_limit_mb is specified (&gt;0), purging starts when RSS exceeds 50% of rss_limit_mb. Pass purge_allocator_interval=-1 to disable this functionality.</td>
</tr>
<tr>
<td>trace_malloc</td>
<td>0</td>
<td>If &gt;= 1 will print all mallocs/frees. If &gt;= 2 will also print stack traces.</td>
</tr>
<tr>
<td>rss_limit_mb</td>
<td>2048</td>
<td>If non-zero, the fuzzer will exit uponreaching this limit of RSS memory usage.</td>
</tr>
<tr>
<td>malloc_limit_mb</td>
<td>0</td>
<td>If non-zero, the fuzzer will exit if the target tries to allocate this number of Mb with one malloc call. If zero (default) same limit as rss_limit_mb is applied.</td>
</tr>
<tr>
<td>exit_on_src_pos</td>
<td>0</td>
<td>Exit if a newly found PC originates from the given source location. Example: -exit_on_src_pos=foo.cc:123. Used primarily for testing libFuzzer itself.</td>
</tr>
<tr>
<td>exit_on_item</td>
<td>0</td>
<td>Exit if an item with a given sha1 sum was added to the corpus. Used primarily for testing libFuzzer itself.</td>
</tr>
<tr>
<td>ignore_remaining_args</td>
<td>0</td>
<td>If 1, ignore all arguments passed after this one. Useful for fuzzers that need to do their own argument parsing.</td>
</tr>
<tr>
<td>focus_function</td>
<td>0</td>
<td>Experimental. Fuzzing will focus on inputs that trigger calls to this function. If -focus_function=auto and -data_flow_trace is used, libFuzzer will choose the focus functions automatically.</td>
</tr>
<tr>
<td>analyze_dict</td>
<td>0</td>
<td>Experimental</td>
</tr>
<tr>
<td>use_clang_coverage</td>
<td>0</td>
<td>Deprecated; don’t use</td>
</tr>
<tr>
<td>data_flow_trace</td>
<td>0</td>
<td>Experimental: use the data flow trace</td>
</tr>
<tr>
<td>collect_data_flow</td>
<td>0</td>
<td>Experimental: collect the data flow trace</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>用libFuzzer搞事情  <a target="_blank" rel="noopener" href="http://pwn4.fun/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/">http://pwn4.fun/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/</a></p>
<p>libFuzzer——编译链接</p>
<p><a target="_blank" rel="noopener" href="https://i-m.dev/posts/20190831-143715.html">https://i-m.dev/posts/20190831-143715.html</a></p>
<p>libFuzzer –用于覆盖率指导的模糊测试的库</p>
<p><a target="_blank" rel="noopener" href="https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#startup-initialization">https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#startup-initialization</a></p>
<p>libFuzzerTutorial </p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md</a></p>
<p>fuzz实战之libfuzzer</p>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/71898.html">https://www.secpulse.com/archives/71898.html</a></p>
<p>fuzzer-test-suite</p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/fuzzer-test-suite">https://github.com/google/fuzzer-test-suite</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/08/28/rabittmq/" title="rabbitMQ教程记录"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: rabbitMQ教程记录</span></a><a class="button is-default" href="/2020/05/15/clusterfuzz%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/" title="clusterfuzz踩坑指南"><span class="has-text-weight-semibold">下一页: clusterfuzz踩坑指南</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com//"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Fstark 2023</span><span></span></p></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>